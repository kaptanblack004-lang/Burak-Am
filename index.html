<!DOCTYPE html>
<html lang="tr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Flappy KardeÅŸim ðŸ”¥</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background: linear-gradient(to bottom, #71c5cf, #ffffff);
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            font-family: Arial, sans-serif;
        }
        #game {
            display: block;
            image-rendering: crisp-edges;
            image-rendering: pixelated;
            touch-action: none;
            border: 2px solid #4a90e2;
            border-radius: 10px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
        }
    </style>
</head>
<body>
    <canvas id="game"></canvas>
    <script>
        const canvas = document.getElementById('game');
        const ctx = canvas.getContext('2d');

        const CANVAS_WIDTH = 288;
        const CANVAS_HEIGHT = 512;
        const BIRD_X = 60;
        const BIRD_WIDTH = 44;
        const BIRD_HEIGHT = 44;
        const PIPE_WIDTH = 52;
        const PIPE_GAP = 130;
        const PIPE_SPACING = 240;
        const GROUND_Y = 412;
        const GRAVITY = 0.4;
        const JUMP = -7;
        const SPEED = 2;
        const GROUND_TILE_WIDTH = 112;

        canvas.width = CANVAS_WIDTH;
        canvas.height = CANVAS_HEIGHT;

        let bird = { y: 200, vy: 0 };
        let pipes = [];
        let score = 0;
        let groundX = 0;
        let gameOver = false;

        const birdImg = new Image();
        birdImg.src = 'https://i.imgur.com/9sZhySO.jpeg';
        const gameoverImg = new Image();
        gameoverImg.src = 'https://i.imgur.com/GqDuolU.jpeg';

        function resize() {
            const scale = Math.min(
                window.innerWidth / CANVAS_WIDTH,
                window.innerHeight / CANVAS_HEIGHT
            );
            canvas.style.width = `${CANVAS_WIDTH * scale}px`;
            canvas.style.height = `${CANVAS_HEIGHT * scale}px`;
        }
        window.addEventListener('resize', resize);
        resize();

        function rectsIntersect(r1, r2) {
            return !(r1.left > r2.right || r1.right < r2.left || r1.top > r2.bottom || r1.bottom < r2.top);
        }

        function update() {
            if (gameOver) return;

            // Bird physics
            bird.vy += GRAVITY;
            bird.y += bird.vy;

            // Pipes move and score
            for (let i = pipes.length - 1; i >= 0; i--) {
                pipes[i].x -= SPEED;
                if (pipes[i].x < -PIPE_WIDTH) {
                    pipes.splice(i, 1);
                    continue;
                }
                if (!pipes[i].scored && pipes[i].x + PIPE_WIDTH < BIRD_X) {
                    score++;
                    pipes[i].scored = true;
                }
            }

            // Add new pipe
            if (pipes.length === 0 || pipes[pipes.length - 1].x < CANVAS_WIDTH - PIPE_SPACING) {
                const minGapTop = 80;
                const maxGapTop = GROUND_Y - PIPE_GAP - 80;
                const gapTop = minGapTop + Math.random() * (maxGapTop - minGapTop);
                pipes.push({ x: CANVAS_WIDTH, gapTop: gapTop, scored: false });
            }

            // Collisions
            const birdRect = {
                left: BIRD_X,
                top: bird.y,
                right: BIRD_X + BIRD_WIDTH,
                bottom: bird.y + BIRD_HEIGHT
            };

            for (let pipe of pipes) {
                // Upper pipe
                const upper = {
                    left: pipe.x,
                    top: 0,
                    right: pipe.x + PIPE_WIDTH,
                    bottom: pipe.gapTop
                };
                if (rectsIntersect(birdRect, upper)) {
                    gameOver = true;
                    return;
                }

                // Lower pipe
                const lowerTop = pipe.gapTop + PIPE_GAP;
                const lower = {
                    left: pipe.x,
                    top: lowerTop,
                    right: pipe.x + PIPE_WIDTH,
                    bottom: GROUND_Y
                };
                if (rectsIntersect(birdRect, lower)) {
                    gameOver = true;
                    return;
                }
            }

            // Ground and ceiling
            if (bird.y < 0 || bird.y + BIRD_HEIGHT > GROUND_Y) {
                gameOver = true;
            }

            // Ground scroll
            groundX -= SPEED;
            if (groundX <= -GROUND_TILE_WIDTH) {
                groundX = 0;
            }
        }

        function draw() {
            // Clear
            ctx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

            // Background gradient
            const grad = ctx.createLinearGradient(0, 0, 0, CANVAS_HEIGHT);
            grad.addColorStop(0, '#A2D2FF');
            grad.addColorStop(0.5, '#E3F2FD');
            grad.addColorStop(1, '#BBDEFB');
            ctx.fillStyle = grad;
            ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

            // Pipes
            ctx.fillStyle = '#5B9A4D';
            for (let pipe of pipes) {
                // Upper
                ctx.fillRect(pipe.x, 0, PIPE_WIDTH, pipe.gapTop);
                ctx.fillStyle = '#4D8233';
                ctx.fillRect(pipe.x - 3, pipe.gapTop - 25, PIPE_WIDTH + 6, 25);
                ctx.fillStyle = '#5B9A4D';

                // Lower
                const lowerTop = pipe.gapTop + PIPE_GAP;
                const lowerHeight = GROUND_Y - lowerTop;
                ctx.fillRect(pipe.x, lowerTop, PIPE_WIDTH, lowerHeight);
                ctx.fillStyle = '#4D8233';
                ctx.fillRect(pipe.x - 3, lowerTop, PIPE_WIDTH + 6, 25);
                ctx.fillStyle = '#5B9A4D';
            }

            // Ground
            const drawGroundTile = (xOffset) => {
                ctx.save();
                ctx.translate(xOffset, GROUND_Y);
                ctx.fillStyle = '#DED895';
                ctx.fillRect(0, 0, GROUND_TILE_WIDTH, CANVAS_HEIGHT - GROUND_Y);
                ctx.fillStyle = '#C8B782';
                ctx.fillRect(0, 0, GROUND_TILE_WIDTH, 25);
                ctx.restore();
            };
            drawGroundTile(groundX);
            drawGroundTile(groundX + GROUND_TILE_WIDTH);

            // Bird
            if (birdImg.complete && birdImg.naturalWidth > 0) {
                ctx.save();
                ctx.translate(BIRD_X + BIRD_WIDTH / 2, bird.y + BIRD_HEIGHT / 2);
                let rot = bird.vy * 0.08;
                rot = Math.max(-0.3, Math.min(0.8, rot));
                ctx.rotate(rot);
                ctx.drawImage(birdImg, -BIRD_WIDTH / 2, -BIRD_HEIGHT / 2, BIRD_WIDTH, BIRD_HEIGHT);
                ctx.restore();
            } else {
                // Fallback
                ctx.fillStyle = '#FFD700';
                ctx.beginPath();
                ctx.arc(BIRD_X + BIRD_WIDTH / 2, bird.y + BIRD_HEIGHT / 2, BIRD_WIDTH / 2, 0, Math.PI * 2);
                ctx.fill();
            }

            // Score
            ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
            ctx.fillRect(0, 0, CANVAS_WIDTH, 80);
            ctx.fillStyle = '#333';
            ctx.font = 'bold 48px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(score.toString(), CANVAS_WIDTH / 2, 40);

            // Game Over
            if (gameOver && gameoverImg.complete && gameoverImg.naturalWidth > 0) {
                ctx.globalAlpha = 0.92;
                ctx.drawImage(gameoverImg, 0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
                ctx.globalAlpha = 1.0;

                // Restart text
                ctx.fillStyle = 'rgba(255, 255, 255, 0.95)';
                ctx.shadowColor = 'black';
                ctx.shadowBlur = 4;
                ctx.font = 'bold 28px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'bottom';
                ctx.fillText('Dokun / TÄ±kla yeniden oyna!', CANVAS_WIDTH / 2, CANVAS_HEIGHT - 30);
                ctx.shadowBlur = 0;
            }
        }

        function gameLoop() {
            update();
            draw();
            requestAnimationFrame(gameLoop);
        }

        function jump() {
            if (gameOver) {
                // Reset
                bird.y = 200;
                bird.vy = 0;
                pipes = [];
                score = 0;
                groundX = 0;
                gameOver = false;
            } else {
                bird.vy = JUMP;
            }
        }

        // Events
        canvas.addEventListener('click', (e) => {
            e.preventDefault();
            jump();
        });
        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            jump();
        });
        document.addEventListener('keydown', (e) => {
            if (e.code === 'Space') {
                e.preventDefault();
                jump();
            }
        });

        // Start
        gameLoop();
    </script>
</body>
</html>
